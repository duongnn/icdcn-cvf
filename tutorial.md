In this tutorial, we will see how to add a program to the framework so that we can analyze the effect of cvf and program transitions.

Tutorial outline:
1. [General steps for including a program into our framework](#general-steps)
2. [Demonstration with Dijkstra's three state program.](#demo)

<div id="general-steps"></div>

## General steps for including a program into our framework

To include a program, says program `A`, into our framework, there are 3 steps:
+ Step 1: Create a package for program `A`
+ Step 2: Inside that package, we add a class for storing the state (variables and their values) of a node in program `A`, says `NodeStateA`. 
		`NodeStateA` is a subclass of the framework's abstract class `NodeStateTemplate` and should override the following abstract methods working with the state of a node.
    
      public int compareTo(Ojbect) // since NodeStateTemplate implements interface Comparable
      public boolean equals(Object)
      public int hashcode()
      public NodeStateA getDeepCopy()
        // Any change to the state of the copy should not affect the state of the current node and vice versa.
      public String toString()
      
    Class `NodeStateA` also needs basic methods such as constructors, getters, and setters.

+ Step 3: We also add to the package a class for storing the configuration (i.e. the combination of the states of all nodes) of program `A`, says `ProgramConfigurationA`. 
		`ProgramConfigurationA` is a subclass of the framework's abstract class `ProgramConfigurationTemplate` and should override methods working with a configuration of program `A`.
    
    First are methods for enumerating program `A`'s configurations.
    
			public int compareTo(Object)  // since ProgramConfigurationTemplate implements interface Comparable
			public ProgramConfigurationA moveToFirstProgramConfig()
			public ProgramConfigurationA moveToNextProgramConfig()
			public ProgramConfigurationA moveToLastProgramConfig()
			public ProgramConfigurationA moveToNthProgramConfig()
    
    We are free to choose the order in which we enumerate all program configurations. Once the enumeration scheme is defined, the methods `compareTo`, `moveToFirst/Next/Nth/LastProgramConfig` must be consistent with that scheme.

    Next are these methods:
    
			public boolean isInsideInvariant()
			public ProgramConfigurationA getDeepCopy()
			public long getSizeOfStateSpace()
			public NodeActionEvaluationResults evaluateANodeActions(int nodeId)
    
    Finally are methods for perturbing the state of a node:
    
			public NodePerturbationResults perturbANodeArbitrarily(int nodeId)
			public NodePerturbationResults perturbANodeWithConstraint(int nodeId)
			public NodePerturbationResults perturbANodeWithConstraintAndTopologyRestriction(int nodeId)

    The constructor for `ProgramConfigurationA` often just calls superclass constructor.


## Demonstration with Dijkstra's ring program <span id="demo"><span>

Description of Dijkstra's ring prorams can be found in Dijkstra's paper [Self-stabilizing systems in spite of Distributed Control](https://dl.acm.org/doi/10.1145/361179.361202). The program described below is the third program (3-state machines) in the paper.

The framework's source code is available [here.](https://github.com/duongnn/icdcn-cvf)

### 2.1. Create a package for Dijkstra program, says `newdijkstra`

### 2.2. Add class `NodeStateNewDijkstra` to the package

In Dijkstra program, state of a node is an integer in the set {0, 1, 2}.
So we have a field says `int nodeValue` for storing this integer.
We also need the field `int nodeId` to differentiate the nodes.

The constructor for `NodeStateNewDijkstra` 

```java
public NodeStateNewDijkstra(int nodeId, int xValue)
```

	We also need methods for setting and getting the values of those fields.

	next, we implement the compareTo() method of Comparable interface, and implement abstract methods of NodeStateTemplate.
   
	   	public int compareTo(Ojbect).
	   		we are free to define how to compare two objects of NodeStateNewDijkstra. 
	   		for example, we use field nodeValue to compare states of two nodes.
	   		If nodeValue are equal, we use nodeId to break the tie.

	   		compare the state of two nodes
	   		return 0 if the states are equal
	   		return -1 (1 respectively) if the state of current node (this) is smaller than (greater than respectively) the state of the node in the argument.
	   		

	   	public boolean equals(Object)
	   		return true if the states of current object (this) and the node in the argument are equal.
	   		return false otherwise
	   		we can use autogenerated code

	   	public int hashcode()
	   		return a hash for the values in the state of current object
	   		we can use autogenerated code

	   	public NodeStateA getDeepCopy()
	   		return a "deep" copy of the state of the current node.
	   		Any change to the state of the copy should not affect the state of the current node and vice versa.

	   	public String toString()
	   		return a string representation of the state of the current node (this).
	   		the purpose is to facilitate the debugging.


### 2.3. Implementing ProgramConfigurationNewDijkstra (step 3 in details)
	For Dijkstra's program, we do not have any program-specific information to keep.
	All necessary information are already declared in the superclass ProgramConfigurationTemplate.
	So the we do not define new fields in ProgramConfigurationNewDijkstra, and its constructor simply calls the superclass' constructor.
	
	next, we implement the compareTo() method of Comparable interface, and implement abstract methods of ProgramConfigurationTemplate.

	to implement compareTo(), we first identify the order in which we enumerate all the program configurations in Dijkstra's program.
	One way to enumerate the program configurations is using lexicographical order.
	For example, with 3 nodes, the enumberation will be:
		0-0-0 (state of node 0, 1, 2 is 0, 0, and 0 respectively)
		0-0-1
		0-1-0
		0-1-1
		...
		1-1-0
		1-1-1

	With the above scheme for enumerating program configurations, we can implement compareTo as follows:
		public int compareTo(Object)
			for(nodeId = 0; nodeId < getNumberOfNodes(); nodeId++){
				compare states of nodeId in two configurations
			}

		we use a supporting function for obtaining state of a node
			public int getNodeValue(int nodeId)

	In the above enumeration scheme, the first program configuration is the one where states of all nodes are 0s
	the last program configuration is where states of all nodes are 2.
	Thus we have
		public ProgramConfigurationA moveToFirstProgramConfig()
			for(nodeId = 0; nodeId < getNumberOfNodes; nodeId++){
				updateStateForANode(NodeState for 0);
			}
			return the current configuration

		public ProgramConfigurationA moveToNextProgramConfig()
			we find the first node from right handside where nodeState is not 2 and increment its nodeState.
			if all nodes have nodeState of 2, it is the last configure. The next configuration will be the first one.

		public ProgramConfigurationA moveToLastProgramConfig()
			for(nodeId = 0; nodeId < getNumberOfNodes; nodeId++){
				updateStateForANode(NodeState for 2);
			}
			return the current configuration

		public ProgramConfigurationA moveToNthProgramConfig(long n)
			this is similar to convert number N from base 10 to base 3 by keep dividing divident by 3 until the divident is 0.
			the remainders obtained through the division process will be the base-3 representation in reverse order.

			digitPosition = getNumberOfNodes - 1
			while(n > 0){
				divide n by 3
				digitValue = n % 3
				n = n/3
				updateStateForANode(digitPosition, new NodeStateNewDijkstra for digitValue)
				digitPosition --;
			}
			all other positions will have value 0;
			while(digitPosition >= 0){
				updateStateForANode(digitPosition, new NodeStateNewDijkstra for 0)
				digitPosition --;
			}

			then return the current program config.

	Now we implement other abstract methods

	   	public ProgramConfigurationA getDeepCopy()
	   		return a "deep" copy of the current configuration.
	   		Any change to the copy should not affect the current configuration and vice versa.
	   			mostly, we replicate the node state map.

	   	public long getSizeOfStateSpace()
	   		return the number of program configurations. 
	   		In Dijkstra's 3-state program, it is 3^{number of nodes}

		public boolean isInsideInvariant()
			By definition in Dijkstra's paper, a configuration is a legitimate when there is exactly one privilege.
			return getNumberOfPrivileges() == 1

	   	public NodeActionEvaluationResults evaluateANodeActions(int nodeId)
	   		this function simulates the situation where a given node is chosen to execute actions.
	   		the chosen node could have multiple actions enabled.
	   		the execution of an enabled action will cause the program change to another configuration called a successor.
	   		this function will return all possible successors that could be obtained when a node execute its actions.
	   		it also return the number of enabled actions (privileges) at that node. This information is useful when we determine whether a node is inside the invariant or not.


	   		The algorithm for the actions executed at a node is as follows:
		        /*
		        The algorithm of Dijkstra 3-state program is as follows:
		            S: is x value of current node
		            L: is x value of left neighbor
		            R: is x value of right neighbor

		            if current node is bottom node (nodeId == 0)
		                if (S+1) mod 3 == R then
		                    S = (S-1) mod 3
		            if current node is top node (nodeId == n-1)
		                if L == R and (L+1) mod 3 != S then
		                    S = (L+1) mod 3
		            other nodes
		                if (S+1) mod 3 == L
		                    S = L
		                if (S+1) mod 3 == R
		                    S = R
		         */
		         note that a node could have more than one privilege
		    the result of this function includes a list of successor and the number of privileges present at that node.
		    we declare 
		    	TreeSet<SuccessorInfo> sucessorInfo = new TreeSet<SuccessorInfo>():
		    	// each successorInfo object is the information about an successor.
		    	// we use Set data structure because we do not want duplicate successor.
		    	int numberOfPrivileges = 0;

		    	//first we get the nodeValue at the current node and its left and right neighbors
		    	int S = getXvalueOfANode(nodeId);
		    	...

		
	next we implement abstract methods for perturbing state of a node.
	these methods are used to simulate the effect of consistency violating faults (cvfs).

		public NodePerturbationResults perturbANodeArbitrarily(int nodeId)
			// state of a node can be an arbitrary value, except the current one.
			// as the nodeValue  is in the set {0, 1, 2}, the perturbation result will be two values different from the current value.


		public NodePerturbationResults perturbANodeWithConstraint(int nodeId)
			// a cvf is a program transition using stale information.
			// the effect of a cvf executed by a node is not necessarily an arbitrary perturbation in the node's state.
			// looking back at algorithm for Dijkstra's 3-state program transition, we observe that execution of an action (a transition) does not change a state arbitrarily.
			// For example, the value of the bottom node only decreases.
			// This function returns the perturbation caused by program transitions executed using stale/incorrect input information.
			// Thus, the results of the perturbation are closer to the actual effect of cvfs.

		public NodePerturbationResults perturbANodeWithConstraintAndTopologyRestriction(int nodeId)
			// in some programs where the action of a node depends on the topology (e.g., the number of neighbor) like in graph coloring program, we think that the effect of cvf also depend on topology.
			// however, in Dijkstra's token ring program, the topology is implicity (i.e. a ring).
			// thus, topology does not affect cvf.









